"""
WARNING: These tests are designed to run in Docker.
Use 'make test' or related commands instead of running pytest directly.
See testing.mdc for more information.

Common Test Failures and Solutions:
---------------------------------

1. Connection Issues:
   - Connection refused:
     * Docker services not running (use docker-compose ps to check)
     * Wrong host/port configuration
     * Health check endpoint not responding
     Solution: Run 'make docker-test' to ensure all services are up

2. Authentication Failures:
   - Token validation errors:
     * Check JWT_SECRET_KEY is set correctly
     * Verify token format in URL
     * Ensure database is accessible for user lookup
     Solution: Check environment variables and database connection

3. Message Sequence Errors:
   - Expected 'chat_message' but got 'welcome':
     * Tests must handle initial welcome message
     * May need to wait for history message
     * Message order is: welcome → history → chat
     Solution: Use the message handling loop to process all messages

4. Database/Redis State:
   - Inconsistent test results:
     * Clear WebSocket manager state between tests
     * Reset Redis message history
     * Clean up database connections
     Solution: Use @pytest.fixture(autouse=True) for cleanup

5. Timing Issues:
   - Tests timing out:
     * Adjust asyncio timeouts
     * Check for slow database queries
     * Verify Redis operations complete
     Solution: Increase timeouts or optimize queries

6. Environment Setup:
   - Missing dependencies:
     * Install websockets package
     * Update aiohttp client
     * Check Python version (3.11+ required)
   
   - Configuration issues:
     * Set DOCKER_SERVICE_HOST
     * Configure DOCKER_SERVICE_PORT
     * Update TEST_DATABASE_URL

Debug Commands:
-------------
- Check services: docker-compose ps
- View logs: docker-compose logs -f backend-test
- Run single test: pytest tests/test_websocket.py::test_message_sending -v
- Debug mode: pytest --pdb -k "test_message_sending"

Required Environment Variables:
----------------------------
DOCKER_SERVICE_HOST=backend-test
DOCKER_SERVICE_PORT=8000
POSTGRES_HOST=db-test
REDIS_HOST=redis-test
TEST_DATABASE_URL=postgresql+asyncpg://postgres:postgres@db-test:5432/test_db
"""

import pytest_asyncio
import asyncio
import websockets
import json
import logging
from httpx import AsyncClient
import pytest
import os
from typing import AsyncGenerator
import time
from websockets.client import connect as ws_connect
from websockets.exceptions import WebSocketException, ConnectionClosedError, InvalidStatusCode
from datetime import timedelta
from sqlalchemy.ext.asyncio import AsyncSession
import aiohttp
from fastapi import FastAPI
from fastapi.testclient import TestClient

from app.core.config import settings, Settings
from app.tests.utils.user import create_random_user
from app.core.auth import create_access_token
from app.db.session import get_async_session, init_db
from app.core.websocket import WebSocketManager, ChatMessage
from tests.conftest import test_settings
from app.models import User

# Use Docker service host and port for testing
DOCKER_SERVICE_HOST = os.getenv("DOCKER_SERVICE_HOST", "backend-test")
DOCKER_SERVICE_PORT = os.getenv("DOCKER_SERVICE_PORT", "8000")

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

@pytest_asyncio.fixture(autouse=True)
async def setup_db():
    """Initialize database before running tests."""
    await init_db()

@pytest_asyncio.fixture(autouse=True)
async def clear_message_history(manager: WebSocketManager):
    """Clear WebSocket manager's message history before each test."""
    manager.message_history.clear()
    manager.message_by_id.clear()
    yield

@pytest_asyncio.fixture
async def db() -> AsyncGenerator[AsyncSession, None]:
    """Get a database session for testing."""
    async for session in get_async_session():
        yield session

@pytest_asyncio.fixture
async def test_client():
    """Create a test client for WebSocket connections."""
    # Configure base URLs for WebSocket and HTTP
    WS_BASE_URL = f"ws://{DOCKER_SERVICE_HOST}:{DOCKER_SERVICE_PORT}"
    HTTP_BASE_URL = f"http://{DOCKER_SERVICE_HOST}:{DOCKER_SERVICE_PORT}"
    
    # Try both health check endpoints
    HEALTH_CHECK_URLS = [
        f"{HTTP_BASE_URL}/health",
        f"{HTTP_BASE_URL}/api/v1/health"
    ]

    # Wait for server to be ready with gentler exponential backoff
    max_retries = 15
    retry_count = 0
    last_error = None
    
    while retry_count < max_retries:
        for health_url in HEALTH_CHECK_URLS:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(health_url) as response:
                        if response.status == 200:
                            logger.info(f"Server ready at {health_url}")
                            return WS_BASE_URL
            except aiohttp.ClientError as e:
                last_error = e
                logger.debug(f"Health check failed for {health_url}: {str(e)}")
                continue
        
        retry_count += 1
        if retry_count == max_retries:
            raise RuntimeError(f"Server not ready after {max_retries} attempts. Last error: {str(last_error)}")
        
        # Gentler backoff: 1, 2, 3, 4... seconds
        await asyncio.sleep(min(retry_count, 10))

    return WS_BASE_URL

@pytest_asyncio.fixture
async def auth_token(db: AsyncSession, test_user: User, test_settings: Settings) -> str:
    """Create a test user and return their authentication token."""
    # Create a test user
    user = await create_random_user(db=db)
    
    # Generate access token
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": str(user.id)},
        expires_delta=access_token_expires
    )
    return access_token

@pytest.mark.asyncio
async def test_websocket_connection(client: TestClient, manager: WebSocketManager):
    """Test that WebSocket connection requires authentication."""
    logger.info("Testing unauthenticated WebSocket connection")
    # --- TEMPORARY DEBUG --- 
    logger.critical(f"DEBUG: Type of client fixture received: {type(client)}")
    logger.critical(f"DEBUG: Client object: {client!r}")
    # --- END TEMP DEBUG ---
    ws_path = "/api/v1/ws" # Path relative to client base URL
    logger.debug(f"Attempting to connect to path: {ws_path}")
    
    try:
        # Use client.websocket_connect without token
        async with client.websocket_connect(ws_path) as _:
            logger.warning("Connection unexpectedly succeeded")
            pytest.fail("Expected connection to be rejected")
    except WebSocketException as e: # Catch generic WebSocketException
        # We expect *some* kind of rejection, maybe not specifically 403/1000
        # The exact error might depend on how the ASGI server handles missing tokens
        logger.info(f"Connection rejected as expected: {type(e).__name__} - {str(e)}")
        # Add assertion based on expected rejection type if known, otherwise just log
    except Exception as e:
        logger.error(f"Unexpected error during WebSocket connection test: {str(e)}", exc_info=True)
        raise

@pytest.mark.asyncio
async def test_authenticated_connection(
    client: TestClient,
    test_user: User,
    test_settings: Settings
): 
    """Test successful connection with a valid token."""
    token = create_access_token(settings=test_settings, data={"sub": str(test_user.id)})
    ws_path_with_token = f"/api/v1/ws?token={token}"
    logger.info(f"Attempting authenticated connection to path: {ws_path_with_token}")
    
    websocket = None
    try:
        # Use client.websocket_connect
        async with client.websocket_connect(ws_path_with_token) as websocket:
            logger.info(f"WebSocket connection successful for user {test_user.id}")
            
            # Check for welcome message
            msg = await asyncio.wait_for(websocket.recv(), timeout=5)
            data = json.loads(msg)
            assert data["type"] == "welcome"
            assert "client_id" in data["metadata"]
            logger.info("Successfully received welcome message")
            
    except WebSocketException as e:
        logger.error(f"WebSocket connection/communication failed: {type(e).__name__} - {str(e)}", exc_info=True)
        pytest.fail(f"WebSocket connection/communication failed unexpectedly: {str(e)}")
    except Exception as e:
        logger.error(f"Error during authenticated connection: {type(e).__name__} - {str(e)}", exc_info=True)
        pytest.fail(f"An unexpected error occurred: {str(e)}")
    # No finally block needed when using 'async with client.websocket_connect'

@pytest.mark.asyncio
async def test_message_sending(
    client: TestClient,
    test_user: User,
    test_settings: Settings
): 
    """Test sending and receiving messages via WebSocket."""
    token = create_access_token(settings=test_settings, data={"sub": str(test_user.id)})
    ws_path_with_token = f"/api/v1/ws?token={token}"
    logger.info(f"Attempting message sending connection to path: {ws_path_with_token}")
    
    try:
        # Use client.websocket_connect
        async with client.websocket_connect(ws_path_with_token) as websocket:
            logger.info(f"Message sending connection successful for user {test_user.id}")
            
            # Process initial messages (welcome, history, presence) - Simplified handling
            initial_messages = []
            welcome_received = False
            start_time = time.time()
            while time.time() - start_time < 10: # Timeout after 10 seconds
                msg = await asyncio.wait_for(websocket.recv(), timeout=5) # Timeout for recv
                data = json.loads(msg)
                initial_messages.append(data)
                if data["type"] == "welcome":
                    welcome_received = True
                    break 
            
            assert welcome_received, "Did not receive welcome message"
            assert "client_id" in initial_messages[0]["metadata"]
            
            # Send a test message
            test_message = {
                "type": "chat_message",
                "content": "Hello, World!",
                "metadata": {
                    "timestamp": str(time.time())
                }
            }
            await websocket.send_json(test_message) # Use send_json for convenience
            logger.info(f"Sent test message: {test_message}")
            
            # Wait for the chat message echo
            chat_echo_received = False
            start_time = time.time()
            while time.time() - start_time < 10: # Timeout after 10 seconds
                response_data = await asyncio.wait_for(websocket.receive_json(), timeout=5) # Use receive_json
                logger.debug(f"Received message: {response_data}")
                
                if response_data["type"] != "chat_message":
                    continue

                assert response_data["content"] == "Hello, World!"
                assert "client_id" in response_data["metadata"]
                assert "user_id" in response_data["metadata"]
                assert response_data["metadata"]["user_id"] == str(test_user.id)
                assert "timestamp" in response_data["metadata"]
                chat_echo_received = True
                break
            
            assert chat_echo_received, "Did not receive chat message echo"
            logger.info("Message exchange successful")
            
    except WebSocketException as e:
        logger.error(f"WebSocket connection/communication failed: {type(e).__name__} - {str(e)}", exc_info=True)
        pytest.fail(f"WebSocket connection/communication failed unexpectedly: {str(e)}")
    except asyncio.TimeoutError:
        logger.error("Timeout waiting for WebSocket message", exc_info=True)
        pytest.fail("Timeout waiting for WebSocket message")
    except Exception as e:
        logger.error(f"Error during message sending test: {type(e).__name__} - {str(e)}", exc_info=True)
        pytest.fail(f"An unexpected error occurred: {str(e)}")
    # No finally block needed when using 'async with client.websocket_connect'